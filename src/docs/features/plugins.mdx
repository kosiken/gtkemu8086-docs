
---
title: Plugins
description: emu8086 emulator Plugins
---

## Plugins

Some text

### HelloWorld

```asm
      ;
        ; by Allison Kosy
        ; http://kosiken.github.io/
        ;
        ; (c) Copyright 2020 krc.
        ;
        ; Creation date: Dec/21/2019.
        ;
        ; Permission is hereby granted, free of charge, to any person obtaining a copy
        ; of this software and associated documentation files (the "Software"), to deal
        ; in the Software without restriction, including without limitation the rights
        ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        ; copies of the Software, and to permit persons to whom the Software is
        ; furnished to do so, subject to the following conditions:

        ; The above copyright notice and this permission notice shall be included in all
        ; copies or substantial portions of the Software.

        ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        ; SOFTWARE.    
;--------------------------------------------------------------------------------------------

;   begin

	push cs
	push cs
	pop ds	
	mov cl, 3
	call init_lcd	
	lea si, [string]
	call myshow
	mov al, 0xc0
	call newline
	inc si
	call myshow
	jmp end	
commands:
	db 0x28, 0x6, 0xf

	
string:
	db "hello world", 0ah
	db "HELLO WORLD", 0ah
	
newline:
	mov ah, al
	
	mov cl, 4
	shr al, cl
	or al, 30h
	out 199, al
	and al, 2fh
	out 199, al
	mov al, ah
	and al, 0xf
	or al, 30h
	out 199, al
	and al, 2fh
	out 199, al
	ret
	
	
init_lcd:
	lea si, [commands]
write:	mov al, [si]
	mov ah, al
	push cx
	mov cl, 4
	shr al, cl
	or al, 30h
	out 199, al
	and al, 2fh
	out 199, al
	mov al, ah
	and al, 0xf
	or al, 30h
	out 199, al
	and al, 2fh
	out 199, al
	pop cx
	inc si
	loop write
	ret
myshow:
	mov al, [si]
	cmp al, 0xa
	jz end_myshow
	mov ch, al
	mov cl,4
	
	shr al, cl
	or al, 10h
	out 199, al
	and al, 0xf
	out 199, al
	mov al,ch
	and al, 0xf
	or al, 10h
	out 199, al
	and al, 0xf
	out 199, al	
	inc si
	jmp myshow

end_myshow:
	ret	

delay: mov dl, 0xa
cont:	dec dl
	cmp dl, 0
	jz end_myshow
	jmp cont
	
end: 
	nop
		
	


```

![lcd](lcdplugin.gif)


## Adding a plugin

### Template

```python



import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, Peas,GObject
from .lcd_view import LCDWidget
from .lcd_pattern_generator import PatternGenerator
from .lcd_driver import LCDDriver
from .lcd_cell import LCDCell

class LcdHitachiPlugin(GObject.Object, Peas.Activatable):
 
    object = GObject.Property(type=GObject.Object)

    def __init__(self):
        GObject.Object.__init__(self)
        
    def do_activate(self):
        window = self.object.get_property("v_box")
        print(repr(window))
        self.panel = LCDWidget()
        self._driver  = LCDDriver(self.panel)
        self.frame = self.panel.get_me()
        self.frame.show_all()
        self.box = Gtk.Box.new(Gtk.Orientation.VERTICAL, 10)
        self.button_box = Gtk.ButtonBox.new(Gtk.Orientation.HORIZONTAL)
        button = Gtk.Button.new_with_label(label="Clear LCD")
        button2 = Gtk.Button.new_with_label(label="Scroll Left")
        button3 = Gtk.Button.new_with_label(label="Scroll Right")    
        self.buttons = [button2, button,button3]    
        for btn in self.buttons:
            self.button_box.add(btn)
            pass

        self.box.add(self.frame)
        self.box.add(self.button_box)
        self.box.show_all()
        window.add(self.box)
        win = self.object.get_property("runner")
        button.connect("clicked", self.cls)
        win.connect("interrupt", self.__mycb)


    def __mycb(self, runner, n):
        cmd = int(n)
        # panel = self.panel
        # panel._driver.recieve4(cmd)
        self._driver.recieve(cmd, 0)
        pass

    def cls(self, box):
        print('ll',repr(box))
        self._driver.cld()
        pass

    def do_deactivate(self):
        self._driver.clear_out(self.panel)
        self.panel.deactivate()
        for btn in self.buttons:
            self.button_box.remove(btn)
        window = self.object.get_property("v_box")
        self.box.remove(self.frame)
        window.remove(self.box)

```
